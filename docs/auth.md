# .Net Core and basics of authentication

My primary focus is frontend apps. Although I used to be a .Net developer. And I always loved how fast and convenient EF Code First is on a product prototype phase. For one of my pet project I decided to build backend server with the latest (May 2017) versions of .Net Core, EF Core and Postgres database. I had deleted Visual Studio and has used Visual Studion Code. Which is a whole different tool. As you may guess things that are essentian in VS just do not exist in other IDEs (even if authored by Microsoft).


In this article I will explain how to add authentication to .Net Core project. I will not touch here how to create a .Net Core Web API application and connectit with a database. If you are interested read the previous article [.Net Core, Entity Framework Core and PostgreSQL](../). The first part shows the concept of Custom middlewares and Action Filters - I'm going to create my own authorization and authentication middleware. The second part describes how to use authentication mechanisms provided by the .Net Core framework.
At end of the lession we will have a tiny web API application that can handle user authentication, authorization and have protected actions.


#Authentication

Authentication in this example is done by the a bit simplified [OAuth2 password grant flow](https://aaronparecki.com/oauth-2-simplified). It allows to exchange username and password for an access token. Obviously, in this case user credentials can be collected by the web app, but that's fine in our case since the web client and the authentication server are provided by us (meaning by the same company).

I'm going to explain a simple athentication and authorization first. Later I'll show how we can use built in authentication features of .Net Core framework. THe example in the article is fast to grasp and easy to implement. Think of it as of a starting point to have authentication in your app. It can be enchanced in future if required.

Let's with user model and test user. Create User entity and add it to DataContext.
```C#
public class User
{
    public long Id { get; set; }
    public string Username { get; set; }
    public string Email { get; set; }
    public string Password { get; set; }
    public string AccessToken { get; set; }
}

public class DataContext : DbContext
{
    public DataContext(DbContextOptions<DataContext> options)
        : base(options)
    { }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        var user = modelBuilder.Entity<User>();
        user.HasIndex(b => b.Username).IsUnique();
        user.HasKey(u => u.Id);
        user.Property(u => u.Id).ValueGeneratedOnAdd();
    }

    public DbSet<Value> Values { get; set; }
    public DbSet<User> Users { get; set; }
}
```

A few words about updates of `DataContext`. I want user Id to be autogenerated and Username - unique. This is the only way I could find to achieve the desired behavior.

Update the `DataContextSeeder`:

```C#
context.Users.Add(new User(){
    Username = "Alex",
    Email = "alex@trainig.com",
    Password = "password"
});
```

> Note: never store unhashed passwords in your database!

To ensure it works lets create a user endpoint and test it.
```C#
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Data;
using Data.Entities;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

namespace Web.Controllers
{
    [Route("api/[controller]")]
    public class UsersController : Controller
    {
        private DataContext _dbContext;
        public UsersController(DataContext dbContext)
        {
            _dbContext = dbContext;
        }

        // GET api/users
        [HttpGet]
        public async Task<IEnumerable<User>> Get()
        {
            return await _dbContext.Users.ToListAsync();
        }

        // GET api/users/5
        [HttpGet("{id}")]
        public async Task<ActionResult> Get(long id)
        {
            var user = await _dbContext.Users.FindAsync(id);
            if (user == null)
            {
                return NotFound();
            }

            return Ok(user);
        }
    }
}
```

> Note: once again, never ever store plain-text (unencrypted) passwords in your database!

We need to handle login request. Let's add LoginModel and the Auth controller.
```C#
public class LoginModel {
    public string Username {get; set;}
    public string Password {get; set;}
}

[Route("api/[controller]")]
public class AuthController : Controller
{
    private readonly TtContext _dbContext;
    public AuthController(TtContext dbContext)
    {
        _dbContext = dbContext;
    }

    [HttpPost("login")]
    public async Task<dynamic> Login([FromBody]LoginModel model)
    {
        var user = _dbContext.Users.FirstOrDefault(u => u.Username == model.Username && u.Password == model.Password);

        if (user != null)
        {
            var accessToken = Guid.NewGuid().ToString();
            user.AccessToken = accessToken;
            await _dbContext.SaveChangesAsync();

            return new
            {
                AccessToken = accessToken
            };
        }

        return new
        {
            Error = "Wrong credentials"
        };
    }
}
```

So here I want to ensure that password entered is correct. In case it's true I create new access token and send it in response.

From now on I'm going to send API requests to server and browser is not the best tool for it. My personal favourites are Fiddler and Postman. Both you can use for free.

So let's test it and ensure that access token is saved in the user entity.




# ToDo
* implement the custom authorization
* implement the custom authentification
* use the .Net provided authorization mechanism
* use the .Net provided attribute authentification