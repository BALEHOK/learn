# .Net Core, Entity Framework Core and PostgreSQL

My primary focus is frontend apps. Although I used to be a .Net developer. And I always loved how fast and convenient EF Code First is on a product prototype phase. For one of my pet project I decided to build backend server with the latest (May 2017) versions of .Net Core, EF Core and Postgres database. I had deleted Visual Studio and has used Visual Studion Code. Which is a whole different tool. As you may guess things that are essentian in VS just do not exist in other IDEs (even if authored by Microsoft).


In this article I will explain how to make EF Core work with Postgresqs database with no help of MS Visual Studio 2017. At end of the lession we will have a tiny web API application that can (re)create a database by the model, store and update basic data.


## Setting up the solution
The first step is to [install](https://www.microsoft.com/net/core) the required libraries for .Net Core. In VS Code you can add C# extension and accept all the suggested installs.


Create solution directory and two new projects - `Data` and `Web`.
``` bash
    mkdir app
    cd app 
```

We are going to create new Web API project in the folder `Web` and Data project in folde `Data` targeting the latest (as of 25.05.2017) .Net Core version.
``` bash
    dotnet new webapi -f netcoreapp1.1 -n Web -o Web
    dotnet new classlib -f netcoreapp1.1 -n Data -o Data
```

Now we are ready to create a solution file and add our projects in the solution:
``` bash
    dotnet new sln -n App
    dotnet sln App.sln add Web/Web.csproj Data/Data.csproj
```

It is said that you can use patterns to specify project files to add (like this `dotnet sln App.sln add **/*.csproj`), but it just did not work for me.


To run the app we need to install all the packages first and then start the app. And yes, you need to `cd` into the startup project folder because pathes within the app (like `AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)` for example) are resolved related to the current directory.
``` bash
    dotnet restore
    cd Web
    dotnet run
```


If you open the URL `http://localhost:5000/api/values` in a browser you will see the application output.


## Entity Framework and PostgreSQL

Lets add Entity Framework to our porject. I am going to work with Entity Framework Core.


Executing the command `dotnet add package` will add a nuget package reference to a `csproj` file.
``` bash
    cd ../Data
    dotnet add package Microsoft.EntityFrameworkCore
```

The `Data.csproj` file should look like this:
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netcoreapp1.1</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="1.1.2" />
  </ItemGroup>
</Project>
```


For the sake of simplicity I add a `Value` entity with autogenerated identity field and integer value field, and register it in the database context. Create `Entities` folder in `Data` project directory and put the `Value` class there:
```C#
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace Data.Entities
{
    public class Value
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public long Id { get; set; }
        public int Num { get; set; }
    }
}
```

Add `DataContext.cs` file to the `Data` project and put the following code there:
```C#
    using Data.Entities;
    using Microsoft.EntityFrameworkCore;

    namespace Data
    {
        public class DataContext : DbContext
        {
            public DataContext(DbContextOptions<DataContext> options)
                : base(options)
            { }

            public DbSet<Value> Values { get; set; }
        }
    }
```

To add some initial data lets create a seeder file (lets name it `DataContextSeeder.cs`) in `Data` folder as well
```c#
    using Data.Entities;

    namespace Data
    {
        public static class DataContextSeeder
        {
            public static void Seed(DataContext context)
            {
                // always drop and create database
                context.Database.EnsureDeleted();
                context.Database.EnsureCreated();

                context.Values.Add(new Value()
                {
                    Num = 42
                });

                context.SaveChanges();
            }
        }
    }
```

Now we are ready to bind our app, Entity Framework and the actual Postgresql database.

Set up the connection string in `appsettings.json`, so it looks as follows
```json
{
  "Logging": {
    "IncludeScopes": false,
    "LogLevel": {
      "Default": "Warning"
    }
  },
  "DbContextSettings" :{
    "ConnectionString" : "User ID=postgres;Password=pwd;Host=localhost;Port=5432;Database=TestDatabase;Pooling=true;"
  }
}
```


In console `cd` to the `Web` project folder.


Add reference to `Data` project in `Web`:
``` bash
    dotnet add reference ../Data/Data.csproj
```

Add `Microsoft.EntityFrameworkCore` and `Npgsql.EntityFrameworkCore.PostgreSQL` packages to `Web` project:
``` bash
    dotnet add package Microsoft.EntityFrameworkCore
    dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL
```

In `Startup.cs`, alter `ConfigureServices` method:
```c#
    public void ConfigureServices(IServiceCollection services)
    {
        // Add framework services.
        services.AddMvc();

        // read from environment variable first
        var connectionString = Configuration["DATABASE_URL"];

        // if environment variable not set, read from configuration
        if (string.IsNullOrEmpty(connectionString))
        {
            connectionString = Configuration["DbContextSettings:ConnectionString"];
        }
        
        services.AddDbContext<DataContext>(opts => opts.UseNpgsql(connectionString));
    }
```


Add all the required usings, make sure that `Microsoft.EntityFrameworkCore` is there. Here follow all the usings required so far:
```c#
    using Data;
    using Microsoft.AspNetCore.Builder;
    using Microsoft.AspNetCore.Hosting;
    using Microsoft.EntityFrameworkCore;
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.Logging;
```


Cool! The context is there. Although we need to seed our database with the default data. And here the .Net dependency resolver nicely comes into play. In the same `Startup.cs` add another parameter to `Configure` method and call our data seeder:
```c#
    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory, DataContext dbContext)
    {
        loggerFactory.AddConsole(Configuration.GetSection("Logging"));
        loggerFactory.AddDebug();

        app.UseMvc();

        DataContextSeeder.Seed(dbContext);
    }
```


It's time to use the context in the controller. In this example I am going to use `DataContext` class directly.


In our `Values` controller add new parameter to the constructor and update the CRUD methods.
``` c#
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Data;
using Data.Entities;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

namespace Web.Controllers
{
    [Route("api/[controller]")]
    public class ValuesController : Controller
    {
        private DataContext _dbContext;
        public ValuesController(DataContext dbContext)
        {
            _dbContext = dbContext;
        }

        // GET api/values
        [HttpGet]
        public async Task<IEnumerable<Value>> Get()
        {
            return await _dbContext.Values.ToListAsync();
        }

        // GET api/values/5
        [HttpGet("{id}")]
        public async Task<ActionResult> Get(long id)
        {
            var val = await _dbContext.Values.FindAsync(id);
            if (val == null)
            {
                return NotFound();
            }

            return Ok(val.Num);
        }

        // POST api/values
        [HttpPost]
        public async Task<StatusCodeResult> Post([FromBody]int value)
        {
            _dbContext.Values.Add(new Value
            {
                Num = value
            });

            await _dbContext.SaveChangesAsync();

            return Ok();
        }

        // PUT api/values/5
        [HttpPut("{id}")]
        public async Task<StatusCodeResult> Put(long id, [FromBody]int value)
        {
            var val = await _dbContext.Values.FindAsync(id);
            if (val == null)
            {
                return NotFound();
            }

            val.Num = value;
            await _dbContext.SaveChangesAsync();

            return Ok();
        }

        // DELETE api/values/5
        [HttpDelete("{id}")]
        public async Task<StatusCodeResult> Delete(long id)
        {
            var val = await _dbContext.Values.FindAsync(id);
            if (val == null)
            {
                return NotFound();
            }

            _dbContext.Values.Remove(val);
            await _dbContext.SaveChangesAsync();

            return Ok();
        }
    }
}
```

We are ready to run the app. A nice bonus by Microsoft - .Net supports watchers. So you can modify the code and your app will rebuild automatically. Add `Microsoft.DotNet.Watcher.Tools` to the `Web.csproj` file:
``` xml
    <ItemGroup>
        <DotNetCliToolReference Include="Microsoft.DotNet.Watcher.Tools" Version="1.0.0" />
    </ItemGroup>
```

Then restore and run the app using dotnet watch command. Click [here](https://docs.microsoft.com/en-us/aspnet/core/tutorials/dotnet-watch) for more info.

``` bash
    dotnet restore
    dotnet watch run
```


The URL `http://localhost:5000/api/values` returs our default number 42. To add another number send POST request with header `Content-Type: application/json`. Use Fiddler, Postman or another similar tool. The raw request data follows:
```
POST http://localhost:5000/api/values HTTP/1.1
Host: localhost:5000
Content-Length: 2
Content-Type: application/json

54
```

In the same way you can PUT and DELETE values.

That is all for now. Happy coding!